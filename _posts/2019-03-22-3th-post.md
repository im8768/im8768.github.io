---
title: "INIT 프로세스"
date: 2019-03-22 06:00:00 -0400
categories: study
---





리눅스상에서 동작하는 모든 프로세스는 init 프로세스에서 생성되어 실행됨

리눅스 커널이 부팅하고나면 사용자 영역에서 init 프로세스가 최초로 실행된 다음 
시스템 동작에 필요한 다른 프로세스들을 순차적으로 실행시킴

부팅 이후 init 프로세스는 백그라운드에서 동작하면서 다른 프로세스를 감시하며
감시중인 프로세스가 좀비상태가 되면 이를 해결한다.


3.1 init 프로세스의 실행 과정

<img width="200" src="https://user-images.githubusercontent.com/34255526/54786966-aaab2580-4c6d-11e9-9829-a0ef9bb1b34d.png">

`if(execute_command){
run_init_process(execute_command);
}`

init post 함수는 run 함수 호출하여 execute_command에 등록된 프로세스 경로를 
가지고 execve() 시스템콜을 호출하는데 이때 경로 설정을 제대로 하지않으면 init 프로세스
를 실행하지 못해 커널 패닉이 일어남

3.2 소스 코드 분석

init 프로세스는 크게 4가지 기능을 수행함
1. 애플리케이션이 디바이스 드라이버에 접근할 때 사용하기 위한 드라이버 노드 생성
2. 시스템 동작에 필요한 환경 변수를 저장하는 프로퍼티 서비스 제공
3. init 프로세스가 해야할 일을 기술한 init.rc 파일 분석 및 수행
4. 자식 프로세스 종료 및 처리

*SIGCHLD 핸들러 등록

시그널 : 리눅스의 프로세스가 정보를 교환하기 위해 주고받는 메시지
시그널 핸들러 : 각 프로세스가 다른 프로세스에서 발생하는 시그널을 처리하기 위한 루틴

`struct sigaction act;
sigaction(SIGCHLD, &act, 0);`

시그널 핸들러를 등록하기 위해서는 시그널 등록함수인 sigaction() 함수에 
sigaction 구조체의 내용을 채워서 인자로 전달하면됨
init 프로세스는 시그널 핸들러를 등록한후 부팅에 필요한 디렉터리를 생성하고 마운트함


*로그 출력장치 초기화

`open_devnull_stdio(); // 실행 로그를 출력하기 위한 장치 생성
log_init();
INFO(“reading config file\n”);`

pen_devnull_stdio() 함수는 /dev 디렉터리 이하에 __null__이라는 디바이스 노드 파일을 
생성하고 표준입출력,에러출력을 모두 __null__장치로 리다이렉션 함

입출력에 관련된 모든 파일이 __null__ 장치로 변경되기 때문에 log_init() 함수를 통해 
새로운 출력 장치를 제공 받아야함

1. log_init() 함수를 통해 “/dev/__kmsg__” 디바이스 노드 파일을 생성함
2. __kmsg__ 장치는 커널의 메시지 출력함수 printk()를 사용하게해줌
- 출력 장치를 생성한 이후 init.rc를 파싱함


`parse_config_file(“/init.rc”);`

parse_config_file() 함수는 인자로 전달된 /init.rc 파일을 읽어 파싱한 후 서비스와 액션 리스트를 구성함
각 리스트는 service_list 와 action_list에 연결 리스트 형태로 등록됨


*qemu

`qemu_init() `

qemu는 pc를 위한 오픈소스 에뮬레이터로
안드로이드 개발자는 qumu 에뮬레이터를 통해 개발중인 에플리케이션을 실행해볼수 있음

*init.rc 파일 분석 및 실행
`snprintf(tmp, sizeof(tmp), “/init.%s.rc”, hardware); 
parse_config_file(tmp);`

parse_config_file(tmp) 함수를 통해 init.{hardware}.rc 파일로부터 서비스 리스트와 액션 리스트 생성
init.rc에서 이미 생성한 서비스 리스트와 액션에 추가됨
init 프로세스는 init.rc 파일의 `early-init, init, early-boot, boot` 섹션에 포함된 명령어들을 순서대로 실행


*early-init

`action_for_each_trigger(“early-init”, action_add_queue_tail);
drain_action_queue();`

action_for_each_trigger() 함수는 섹션의 명령어들을 실행 큐인 action_add_quere_tail에 
저장하고 drain_action_queue() 함수를 통해 저장된 명렁어들을 하나씩 실행함


*드라이버 노드 생성

device_init() 함수를 통해 디바이스 노드를 생성


*프로퍼티 서비스 초기화

1. property_init() 함수를 통해 프로퍼티 서비스 초기화
2. load_565rle_image(INIT_IMAGE_FILE)부팅로고 출력
3. property_set()함수를 통해 생성한 프로퍼티 영역에 초기값 설정
+ 설정된 프로퍼티는 property_get() API를 통해 조회 가능
4. 액션 리스트의 init 섹션 명령어 실행
`action_for_each_trigger(“init”, action_add_queue_tail);
drain_action_queue();`
5. 프로퍼티 서비스 시작
`property_set_fd = start_property_service();`


*자식 프로세스 종료
 init 프로세스는 자식 프로세스의 종료 처리를 위한 핸들러를 따로 정의해두었음
1. socketpair() 함수가 서로 연결된 소켓쌍(signal_fd, signal_recv_fd)를 생성 
2. signal_fd의 값이 1로 설정됨. 
3. signal_recv_fd의 값도 1로 설정됨
4. signal_recv_fd의 값을 감시하던 이벤트 처리 핸들러가 프로세스 종료 처리 핸들러를 호출

그 외 init.rc의 boot 섹션은 서비스 리스트에 존재하는 프로세스의 리스트를 하나씩 실행하는 
class_start 명령어를 가지고있음


*POLL 이벤트 등록

Init 의 4가지 기능 중 다음 세가지를 위한 이벤트 

1. 디바이스 노드 생성 이벤트 처리
2. 프로퍼티 서비스 요청 이벤트 처리
3. SIGCHLD 시그널 처리

`//ufds = pollfd 구조체변수`

`ufds[0].fd = device_fd;`

`ufds[0].events = POLLIN;`

`ufds[1].fd = property_set_fd;`

`ufds[1].events = POLLIN;`

`ufds[2].fd = signal_recv_fd;`

`ufds[2].events = POLLIN;`

`fd_count = 3;`

.events를 통해 모니터링 해야할 이벤트를 poll() 함수의 인자로 넘기고 poll() 함수를 통해 
이벤트를 감시하게 됨


3.3 init.rc 파일 분석 및 실행

init.rc 파일은 안드로이드를 빌드해야 생성되는 init 프로세스와 달리 안드로이드 플랫폼의 소스코드에서 바로 살펴볼 수 있음.

`on init
	#setup the global environment
	export ...

on boot
	# basic network init
	ifup ...
on property:ro.kernel.qumu=1
.
.


service console
service adbd
service servicemanager
.
.
.`

init.rc 파일은 크게 on키워드로 시작하는 액션 리스트와 ‘service’ 키워드로 시작하는 서비스 리스트로 나뉨

액션 리스트
1. 시스템 환경변수 등록
2. 리눅스 명령어를 통해 디렉터리 생성 또는 특정 파일에 대한 퍼미션 제공
이후 시스템 동작과 관련된 디렉터리를 마운트

서비스 리스트
1. 부팅 시 init 프로세스가 실행하는 프로세스를 기술
부팅음을 실행하는 등의 일회성 프로그램이나 백그라운드로 구동되며 시스템 운영에 관여하는 데몬 프로세스 등이 있다.

3.3.3 init.rc 파싱 코드 분석

위의 parse_config_file()함수는 인자로 전달되는 파일을 읽어 연속적인 문자열로 생성하고 각 열을 파싱함

`int parse_config_file(const char *fn)
{
	char *data;
	data = read_file(fn, 0); //메모리를 확보한후 시작주소를 반환
	parse_config(fn,data);//생성된 문자열로 액션,서비스 리스트 생성
}`

parse_config 함수는 인자로 전달된 파일의 끝을 만날때까지 파일의 각 라인을 파싱함

`parse_config(const char *fn, char *s)
{
	for(;;) {
		switch (next_token(&state)) {
			case T_NEWLINE:
			if (nargs) {
				int kw = lookup_keyword(args[0]);
				if (kw_is(kw, SECTION)) {
					parse_new_section(&state, kw, nargs, args);
				}
			}
		}
	}
}`

next_token 함수는 문자열을 라인단위로 나눈후 lookup_keyword() 함수를 호출
lookup_keyword 함수는 init.rc 파일의 첫단어에 해당하는 keyword_list 구조체 배열에서 배열의 번호를 반환

*KEYWORD 매크로
KEYWORD 매크로는 parse.c와 keyword.h에 정의되어 있는데 각 파일에 정의된 매크로는 다른 역할을 함

parse.c에 정의된 매크로는 KEYWORD 리스트를 keyword_list 구조체 배열로 변환하는 역할을 하고 keyword.h 에 
정의된 KEYWORD 매크로는 KEYWORD 리스트에 1번부터 순서대로 번호를 할당함

`#define SECTION 0X01 // on 과 service로 구별되는 액션, 서비스 리스트를 구분함
#define COMMAND 0x02 // init 프로세스가 실행하는 명령어를 처리하기위해 실행 함수와 매핑
(예 : mkdir 키워드는 디렉터리를 생성하는 do_mkdir과 매핑됨)
#define OPTION 0x04 // 명령어나 서비스리스트의 프로세스를 실행할 때 실행조건 부여`


KEYWORD 리스트들은 KEYWORD 매크로를 통해 

`[“리스트 번호”] = {“키워드”, “그룹”, “인자개수”,“매핑 함수”}` 

형태의 keyword_info 구조체 배열의 리스트로 변경됨


parse_new_section 함수는 kw_is()매크로에 의해 구분된 명령어를 액션 리스트나 서비스 리스트에 등록함
on 섹션 이후의 명렁어는 service 섹션을 만나기 전까지 액션리스트에 등록되고 service 이하는 서비스 리스트에 등록됨


