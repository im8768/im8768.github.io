10. 자바 서비스 프레임워크

10.1 자바 서비스 프레임워크

  자바 서비스 프레임워크는 자바 기반의 애플리케이션 프레임워크에서 동작하는 자바 시스템 서비스를 개발할 때 이용하는 클래스의 집합이다.

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284183-09fbf200-7de5-11e9-9019-4b293e18d634.jpg">
</div>

1. 서비스 생성 :  자바 서비스 프레임워크에서 자바 서비스를 개발하는 방법은 두가지다.
> Binder 클래스를 상속받아 개발하는 방식 : 서비스를 정밀하게 제어해야 할 때 적절하며 자바 시스템 서비스를 개발할 때도 쓰임
> Service 클래스를 상속받아 개발하는 방식 : 일반적으로 특정 작업을 주기적으로 백그라운드에서 수행하는 프로세스를 구현하는 데 사용됨

2. 바인더 IPC 처리 : 자바 서비스 프레임워크에서는 바인더 IPC를 지원하기 위해 JNI를 통해 연결된 네이티브 서비스 프레임워크의 구성요소를 재사용한다.

10.1.1 자바 서비스 프레임워크의 계층별 요소

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284185-0a948880-7de5-11e9-9064-4dbaa0d34aae.jpg">
</div>

- 각 레이어별 네이티브 서비스 프레임워크와의 차이점

1. 서비스 사용자의 서비스 레이어에 매니저 클래스가 위치함
2. RPC 레이어에 AIDL 도구로 자동 생성된 스텁과 프록시 클래스가 위치함
3. IPC 레이어에 위치한 구성요소가 JNI를 통해 네이티브 서비스 프레임워크의 구성요소와 연결됨

- 서비스 레이어

  네이티브 서비스 프레임워크와는 달리 FooManager 클래스를 구현하는 이유는 SDK에 SeviceManager 클래스가 포함되지 않아서 ServiceManager를 이용하여 시스템 서비스를 등록하거나 시스템 서비스를 검색할 수 없기 때문이다

  따라서 시스템 서비스 개발자는 애플리케이션 개발자가 시스템 서비스를 이용할 수 있게 SDK에 래퍼 클래스를 포함시켜야 한다.

- RPC 레이어

  자바 서비스 프레임워크는 안드로이드 플랫폼에 포함된 AIDL 언어와 컴파일러를 이용해 서비스 프록시와 서비스 스텁을 자동으로 생성한다. 
> AIDL : 안드로이드에서 프로세스 간의 IPC를 통해 상호작용하는 자바 기반의 코드를 작성하는데 사용되는 인터페이스 정의 언어

- IPC 레이어

  바인더 IPC를 위해 네이티브 서비스 프레임워크에서는 BpBinder와 BBinder 클래스를 제공하지만 자바 서비스 프레임워크에서는 BinderProxy와 Binder 클래스가 이용된다.

  자바 서비스 프레임워크에서는 JNI를 통해 네이티브 서비스 프레임워크의 바인더 IPC를 재사용 한다. (BinderProxy와 Binder는 JNI를 통해 네이티브 서비스 프레임워크와 BpBinder BBinder 클래스의 기능을 재사용한다)


<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284187-0a948880-7de5-11e9-9387-9d06b8f27df3.jpg">
</div>

> BinderProxy와 Binder가 상호작용하는 경우에 BinderProxy의 transact() 메서드를 호출하면 Binder의 execTransact() 메서드가 호출됨

  BBinder에 기능을 추가하려면 BBinder를 상속받은 서비스 스텁 클래스를 정의하고 onTransact() 함수를 재정의하면 된다.

10.1.2 자바 서비스 프레임워크의 클래스별 상호작용

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284188-0a948880-7de5-11e9-9958-4fabb3e8a584.jpg">
</div>

- 서비스 사용자가 Foo() 메서드를 호출하는 과정과 BinderProxy의 transact() 메서드가 JNI 네이티브 함수로 Bpbinder의 transact() 메서드를 호출하는 과정이 추가됨
- 이후는 네이티브 서비스 프레임워크와 동일함

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284190-0a948880-7de5-11e9-8b70-a18cd0416206.jpg">
</div>
- BBinder의 transact() 함수가 JavaBBinder 네이티브 서비스 스텁을 이용해 Binder의 execTransact() 메서드를 호출하는 과정이 추가됨

<FooService 서비스를 시스템에 등록하고 사용하는 과정>

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284191-0b2d1f00-7de5-11e9-874e-416556383738.jpg">
</div>

1) 서비스 등록요청(서비스) : FooService 서비스는 자신을 시스템에 등록하기 위해 ServiceManager 클래스를 이용해 이 과정을 처리한다.

2) 서비스 등록(서비스 매니저) : ServiceManagerProxy 서비스 프록시는 addService() 메서드의 호출 정보를 RPC 데이터로 변환한다. 바인더 RPC 데이터는 Parcel 클래스에 저장되어 BinderProxy에 전달되고 JNI를 통해 BpBinder에 전달된다.

3) 서비스 검색 요청(서비스 사용자) : SDK에서 제공하는 getSystemService() 메서드를 호출해서 서비스를 검색한다.

4) 서비스 검색(서비스 매니저) : getSystemService()는 ServiceManager의 getService() 메서드를 호출해 시스템에서 FooService 서비스를 검색한다.

5) foo() 서비스 프록시 메서드 호출(서비스 사용자) : foo() 메서드를 호출하고나면 호출 정보를 RPC 데이터로 변환하다음 BinderProxy를 통해 Bpbinder에 전달한다.

6) foo() 서비스 스텁 메서드 실행(서비스) : BBinder는 바인더 드라이버로부터 바인더 RPC 데이터를 전달받아 JavaBBinder를 통해 Binder의 execTransact() 메서드를 호출한다. 이후 IFooService.Stub 서비스 스텁의 onTransact() 메서드로 RPC 데이터가 전달되고 FooService의 foo() 서비스 스텁 메서드를 호출한다.

10.2 동작 메커니즘

10.2.1 자바 서비스 프레임워크 초기화

  app_process 프로세스가 실행되면 AndroidRuntime 클래스에서 startReg() 함수를 호출해서 JNI 네이티브 함수를 달빅 가상 머신으로 로딩한다.
> 이 때 register_android_os_Binder() 함수를 호출해서 등록되는 JNI 네이티브 함수가 자바 서비스 프레임워크와 관련있는 함수이다.

```
int register_android_osBinder(JNIEnv* env)
{
   if (int_register_android_os_Binder(env) < 0 )
      return –1;
   if (int_register_android_os_BinerInternal(env) < 0 )
      return –1;
   if (int_register_android_os_BinderProxy(env) < 0 )
      return –1;
   if (int_register_android_os_Parcel(env) < 0 )
      return –1;
// 함수명의 마지막 단어는 JNI 네이티브 함수를 사용하는 자바 클래스의 이름
}
```

10.2.2 Binder

- Binder 클래스의 JNI 설정

  Binder 클래스를 사용하려면 달빅 가상 머신에 Binder의 네이티브 메서드를 위한 JNI 네이티브 함수를 등록해줘야 한다. 
> int_register_android_os_Binder() 함수가 호출되면 Binder 클래스의 일부 정보를 전역 변수 gBinderOffsets에 저장하고 Binder 클래스의 네이티브 메서드와 JNI 네이티브 함수를 매핑

```
static int int_register_android_os_Binder(JNIEnv* env)
{
   jclass clazz;

   clazz = env->FindClass(kBinderPathName);
   LOG_FATAL_IF(clazz == NULL, “Unable to find class android.os.Binder”);
// 달빅 가상머신에서 `android.os.Binder` 클래스를 찾은다음 bindernative_offset_t 구조체에 JNI 네이티브 함수에서 사용할 Binder 클래스의 주요 정보를 저장

   gBinderOffsets.mClass = (jclass) env->NewGlobalRef(clazz);
   gBinderOffsets.mExecTransact = env->GetMethodID(clazz, “execTransact”, “(IIII)Z”); 
// binder의 클래스정보, execTransact() 메서드 ID, mObject 필드 ID
   assert(gBinderOffsets.mExecTransact);

   gBinderOffsets.mObject = env->GetFieldID(clazz, “mObject”, “I”);
   assert(gBinderOffsets.mObject);

   return AndroidRuntime::registerNativeMethods(env, kBinderPathName, gBinderMethods, NELEM(gBinderMethods));
// Binder의 네이티브 메서드와 매핑되는 JNI 네이티브 함수를 달빅 가상 머신에 등록
}

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284194-0b2d1f00-7de5-11e9-98bd-0ecd71ee57f9.jpg">
</div>

- Binder 객체 생성
  
  Binder 클래스는 바인더 IPC를 위해 BBinder의 기능을 사용하기 때문에 Binder 객체가 생성될 때 BBinder와 함께 생성되어야 한다.

```
// Binder.java 생성자의 소스코드
public class Binder implements IBinder {
   private native final void init();
   public Binder() {
      init(); // android_os_Binder_init() 함수에 연결
   }
}
```

```
//android_os_Binder_init() 함수
static void android_os_Binder_init(JNIEnv* env, jobject clazz)
{
   JavaBBinerHolder* jbh = new JavaBBinderHolder(env, clazz);
// JavaBBinderHolder 클래스 객체 생성
   if (jbh == NULL) {
      jniThrowException(env, “java/lang/OutOfMemoryError”, NULL);
      return;
   }
   LOGV(“Java Binder %p: acquiring first ref on holder %p”, clazz, jbh);
   jbh->incStrong(clazz);
   env->SetIntField(clazz, gBinderOffsets.mObject, (int)jbh);
// SetIntField() JNI 함수를 이용해 Binder의 mObject 변수에 생성된 JavaBBinderHolder 인스턴스의 주소 저장
}
```

- JavaBBinder 객체 생성

  JavaBBinderHolder 클래스의 생성자를 살펴보면 생성자는 단순히 mObject 변수에 Binder 객체의 주소값을 저장할 뿐이다. (android_util_Binder.cpp)
  JavaBBinder의 인스턴스는 JavaBBinderHolder의 get() 함수에서 생성된다.

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284195-0b2d1f00-7de5-11e9-8392-501f84e0efba.jpg">
</div>

1. Binder의 생성자가 호출되면서 네이티브 메서드인 init()이 호출, 연결된 JNI 네이티브 함수에 의해 JavaBBinderHolder 객체가 생성된다. 
2. JavaBBinderHolder 생성자는 init() 메서드를 호출한 Binder 객체의 주소를 인자값으로 받아 mObject 변수에 저장한다.
3. JavaBBinder는 JavaBBinderHolder의 get() 함수를 호출하면 생성된다. 이 때 JavaBBinder 생성자는 JavaBBinderHolder의 mObject 변수를 인자로 받아 자신의 mObject 변수에 저장한다.

- Binder 클래스와 JavaBBinder 서비스 스텁 클래스의 상호작용

  BBinder의 transact()가 호출되면 기본적으로 onTransact()가 호출된다. 기본으로 제공하는 바인더 RPC 함수 이외에 새로운 기능을 사용하려면 BBinder를 상속받은 서비스 스텁 클래스에서 onTransact() 메서드를 재정의해야 한다.

  C++로 작성된 클래스에서 JNI를 통해 자바 클래스의 메서드를 호출하려면 CallxxxMethod() JNI 함수를 이용해야 한다.
> execTransact() 메서드가 boolean 타입을 반환하므로 CallBooleanMethod() JNI 함수를 통해 Binder의 execTransact() 메서드를 호출할 수 있음

  CallBooleanMethod() JNI 함수를 호출하려면 Binder 객체의 주소값, execTransact() 메서드 ID 정보가 필요하다.

  Binder 클래스의 execTransact() 메서드가 호출되면 onTransact() 메서드를 호출한다.(Binder.java)
> 네이티브 서비스 스텁처럼 자바 서비스 스텁 클래스도 Binder 클래스를 상속받아 onTransact() 함수를 재정의하고 RPC 코드에 맞는 서비스 스텁 메서드를 호출하는 기능을 추가하면 된다.

10.2.3 BinderProxy

- BinderProxy 클래스를 위한 JNI 설정

  BinderProxy 클래스를 사용하려면 달빅 가상 머신에 BinderProxy의 네이티브 메서드를 위한 JNI 네이티브 함수를 먼저 등록해줘야 한다. 
> int_register_android_os_BinderProxy() 함수가 호출되면 gBinderProxyOffsets 전역 변수에 BinderProxy 클래스의 일부 정보를 저장하고 BinderProxy 네이티브 메서드와 JNI 네이티브 함수를 매핑한다.

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284197-0b2d1f00-7de5-11e9-9cd2-fbedaf3f2599.jpg">
</div>

> mConstructor 변수에 생성자 메서드 ID를 저장하는데, 이 생성자 메서드 ID는 JNI 네이티브 함수에서 BinderProxy 객체를 생성할 때 사용된다.

- BinderProxy 객체 생성

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284198-0bc5b580-7de5-11e9-9411-56e6e5f01939.jpg">
</div>

  BinderProxy 클래스도 바인더 IPC를 수행하는 데 네이티브 서비스 프레임워크의 BpBinder의 기능을 사용하므로 BinderProxy 객체가 생성될 때 BpBinder 객체가 필요하다. > BpBinder 객체는 Parcel(c++)의 readStrongBinder() 함수에서 생성되며 따라서 BinderProxy 객체도 Parcel(java)의 readStrongBinder() 메서드를 호출할 때 생성됨

  C++에서 JNI를 통해 자바 레이어에 객체를 생성하려면 NewObject() JNI 함수를 이용하면 된다. javaObjectForBinder() 함수를 살펴보면 NewObject() JNI 함수를 이용해 BinderProxy 객체를 생성한 다음 BinderProxy의 mObject 변수에 BpBinder 객체를 저장한다.




10.3 자바 서비스 구현

10.3.1 알람 매니저 서비스의 구조 분석

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284200-0bc5b580-7de5-11e9-89cd-dcec686cc18b.jpg">
</div>

- 알람 매니저 서비스 구현 방식

  네이티브 시스템 서비스를 구현하려면 서비스 인터페이스, 서비스 프록시, 서비스 스텁, 서비스를 개발자가 모두 구현해야 하지만 자바 시스템 서비스를 구현할 때는 AIDL을 이용해 자동으로 생성할 수 있다.

```
//알람 매니저 서비스 코드
package android.app;
import android.ap.PendingIntent;

interface IAlarmManager {
   void set(int type, long triggerAtTime, in pendingIntent operation);
   void setRepeating(int type, long triggerAtTime, in pendingIntent operation);
   void setInexactRepeating(int type, long triggerAtTime, in pendingIntent operation);
   void setTimeZone(String zone);
   void remove(in PendingIntent operation);
}
//5개의 메소드가 선언되어있음
```

  서비스 스텁 클래스는 Binder 클래스의 onTransact() 메서드를 재정의하여 시스템의 바인더 RPC 기능을 추가하므로 알람 매니저 서비스의 서비스 스텁 클래스도 onTransact() 메서드를 재정의하여 IAlarmManager 인터페이스에 정의된 5개의 메서드 관련 코드를 추가했다.

```
//AlarmManagerService.java
class AlarmManagerService extends IAlarmManager.Stub {
   private final Context mContext;

   public AlarmManagerService(Context context) {
      mContext = context;
   }

   public void set(int type, long triggerAtTime, in pendingIntent operation) {
      setRepeating(type, triggerAtTime, 0, operation);
   }
}
```
  AlarmManagerService 클래스는 서비스 인터페이스의 set() 메서드를 재정의하여 실질적인 기능을 구현하고 있다.

- 알람 매니저 서비스 사용

  시스템 서비스를 사용하려면 SDK의 getSystemService() 메서드를 이용해야 한다. 알람 매니저 서비스는 Context 클래스의 ALARM_SERVICE 변수를 인자로 getSystemService() 메서드를 호출하면 애플리케이션을 사용할 수 있고 ContextImpI 클래스의 getAlarmManager() 메서드에서 이를 구현하고 있다.

```
//ContextImpI.java
private AlarmManager getAlarmManager() {
   synchronized (sSync) {
      if (sAlarmManager == null) {
         IBinder b = serviceManager.getService(ALARM_SERVICE);
         IAlarmManager service = IAlarmManager.Stub.asInterface(b);
         sAlarmManager = new AlarmManager(service);
      }
   }
   return sAlarmManager;
}

1. ServiceManager의 getService() 메서드로 서비스를 요청하면 알람 매니저 서비스를 가리키는 BinderProxy 객체를 반환받는다
2. asInterface() 메서드를 이용해 Stub.Proxy 서비스 프록시 클래스의 객체를 획득한다.
3. AlarmManager의 인스턴스를 생성하여 반환한다.

10.3.2 HelloWorldService 시스템의 서비스의 구현

- HelloWorldService 설계

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284201-0bc5b580-7de5-11e9-9f95-7300c70d52d6.jpg">
</div>

- HelloWorldService 구현

- 서비스 인터페이스, 서비스 프록시, 서비스 스텁의 자동 구현

```
//HelloWorld.aidl
package android.app;

interface IHelloWorld{
   void printHello();
}
```
1. IAlarmManager.aidl 파일이 위치한 경로에 위치시킨다. 
> frameworks/base/core/java/android/app/IAlarmManager.aidl

2. IHelloWorld.aidl 파일이 컴파일 될 수 있게 Android.mk 설정파일을 수정해야한다.
> frameworks/base/Android.mk 파일의 LOCAL_SRC_FILES 항목에서 IAlarmManager.aidl 밑에 IHelloworld.aidl을 추가하면 SDK를 변경하게 된다.

- HelloWorldService 서비스의 구현

  서비스는 서비스 스텁 클래스를 상속받아 구현하면 된다. AIDL 컴파일러에 의해 자동으로 생성된 IHelloWorld.Stub 서비스 스텁 클래스를 상속 받아 구현한다.
> HelloWorldService extends IHelloWorld.stub

- HelloWorldService 서비스의 등록

  자바 시스템 서비스는 ServerThread 클래스의 run() 메서드에서 생성하여 안드로이드 플랫폼에 등록한다. HelloWorldService 시스템 서비스도 run() 메서드에서 HelloWorldService의 인스턴스를 생성하고 자바 서비스 매니저의 addService() 메서드를 통해 시스템에 등록한다.


> ServiceManager.addService(Context.HELLO_SERVICE, helloWorldService);

이후 Context.java 에 HELLO_SERVICE 문자열 상수를 추가한다
> public static final String HELLO_SERVICE = “hellowrold”;

10.3.3 HelloWorldService 시스템 서비스의 이용

- HelloWorldManager 구현

```
//HelloWorldManager.java

package android.app;
import android.os.RemoteException;

public class HelloWorldManager
{
   private final IHelloWorld mService;

   HelloWorldManager(IHelloWorld service) {
      mService = service;
   }// HelloWorldManager 클래스의 생성자는 IHelloWorld.Stub.Proxy 클래스의 인스턴스를 인자로 전달 받는다. HelloworldManager 클래스는 android.app 패키지에 포함된 클래스에서는 생성할 수 있으나 SDK를 이용하는 개발자가 임의로 생성할 수는 없다.

   public void printHello() {
      try {
         mService.printHello();
      } catch (RemoteException ex) {
      }
   }// 이 메서드는 RemoteException을 던지므로 호출 시 try/catch 문으로 감싸줘야 한다.
}
```
> RemoteException : 바인더 RPC 중에 발생하는 예외로 호출한 서비스가 존재하지 않을 경우 발생함

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284202-0bc5b580-7de5-11e9-9896-055439a41d05.jpg>
</div>


HelloWorldService를 이용하기 위해서 getSystemService() 메서드를 Context.HELLO_SERVICE 인자값과 함께 호출한 후, 반환값을 HelloWorldManager 타입으로 형변환하면 HelloWorldService 서비스를 이용할 수 있다.
```
HelloWorldManager hello = (HelloWorldManager)getSystemService(Context.HELLO_SERVICE);
```

10.3.4 HelloWorldService 시스템 서비스 빌드

> $ make

  안드로이드 플랫폼은 SDK가 변경되면 경고 메시지를 출력한다. 경고 메시지는 새로 추가된 클래스가 SDK API를 변경하게 되므로 @hide 주석을 추가하거나 current.xml 파일을 make update-api 명령어를 통해 갱신하라고 알려준다.

  make update-api 명령어를 통해 API 정보를 갱신 후 변경된 API 정보는 current.xml 파일에서 확인할 수 있다.

  컴파일이 정상적으로 끝나면 system.img 파일이 생성된다. 생성된 파일을 <ANDROID_SDK> /platforms/android-8/images에 복사한다
  에뮬레이터를 실행하여 HelloWorldManager를 통해 HelloWorldService를 이용하는 애플리케이션을 작성 후 printHello() 메서드를 호출하면 Hello, World 라는 메시지를 확인할 수 있다.

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/58284203-0c5e4c00-7de5-11e9-9719-e33b3edffd16.jpg>
</div>

  HelloWorldService 시스템 서비스가 정상적으로 등록되어 동작하는지 확인하려면 adb shell 명령어를 입력한 후 셸 프롬프트가 출력되면 service list 명령어를 입력한다.



