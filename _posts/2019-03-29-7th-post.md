5.3 ZygoteInit 클래스의 기능

<그림>

```
public static void main(String argv[]) {
   try {
      //1. 새로운 안드로이드 애플리케이션의 실행 요청을 받기 위한 소켓 바인딩
      //init.rc 파일에서 app_process 실행시 `/dev/zygote` 로 등록한 소켓 사용
      registerZygoteSocket();
      .
      //2. 안드로이드 애플리케이션 프레임워크에서 사용할 클래스와 리소스를 로딩
      //새로 생성되는 프로세스에도 그대로 사용되므로 빠르게 생성 가능
      preloadClasses();
      preloadResources();
      .
      //3. SystemServer 실행
      //zygote 실행할 때 `--start-system-server` 옵션에 의해 호출
      if (argv[1].equals(“ture”)) {
         startSystemServer();
      }
      .
      if (ZYGOTE_FORK_MODE) {
         runFortMode();
      } else {
         // 새로운 안드로이드 애플리케이션 실행 요청을 처리
         runSelectloopMode();
      }
      closeServerSocket();
   } catch (MethodAndArgsCaller caller) {
        caller.run();
      } catch (RuntimeException ex) {
        log.e(TAG, “Zygote died with exception”, ex);
        closeServerSocket();
        throw ex;
      }
}


```

5.3.1 /dev/socket/zygote 소켓 바인딩
ZygoteInit 클래스는 아래 코드에서 생성된 소켓을 사용해서 ActivityManager로부터 전달되는 생성 요청을 수신한다.
생성될 소켓의 이름, 종류, 접근 권한이 두 번째 줄에 기술 되어있다.

```
service zygote /system/bin/app_process –Xzygote /system/bin —zygote —start-system-server
   socket zygote stream 666 // <--
   onrestart write /sys/android_power/request_state wake
   onrestart write /sys/power/state on
```

ZygoteInit 클래스의 main()메서드는 가장 먼저 registerZygoteSocket() 메서드를 호출

registerZygoteSocket()에서는 LocalServerSocket 클래스의 정적 변수인 sServerSocket에 새로운 객체를 생성 및 할당 
`sServerSocket = new LocalServerSocket(createFileDescriptor(fileDesc));`

System.getenv() 메서드를 호출해서 init프로세스가 ANDROID_SOCKET_zygote 환경변수로 등록한 소켓의 파일 디스크립터를 가져옴. 가져온 값을 이용해 LocalServerSocket 클래스의 인스턴스를 생성하고 5.3.1과 바인딩
`String env = System.getenv(ANDROID_SOCKET_ENV);`

5.3.2 애플리케이션 프레임워크에 속한 클래스와 플랫폼 자원의 로딩

Zygote 클래스는 preloadClasses() 와 preloadResources() 메서드를 호출
> 각 메서드는 애플리케이션 프레임워크에 포함되는 클래스와 아이콘, 이미지, 문자열 등의 자원을 미리 메모리에 로딩하고 로딩한 클래스와 자원에 대한 연결 정보를 생성


+ preloadClasses() 주요코드

> ZygoteInit.class.getClassLoader().getResourceasStream(PRELOADED_CLASSES); // 입력스트림을 먼저 생성
> BufferedReader br = new BufferdReader(new InputStreamReader(is), 256); // 입력 스트림으로 한줄씩 읽어들임
> line = line.trin(); // 라인이 빈 줄이면 다음줄을 읽음
> Class.forName(line); // 필요한 클래스를 메모리에 동적로딩, 실제 메모리상에 인스턴스를 생성하는 것이 아니라 클래스 정보를 메모리에 로딩하고 정적 변수 초기화

* 애플리케이션 프레임워크에 포함된 리소스의 로딩
안드로이드 개발툴에서 자동으로 생성해주는 R클래스를 통해 접근하며 이를 통해 사용할 수 있는 리소스에 대한 구성정보는 XML로 기술

+ preladResources() 주요코드

> mResources = Resources.getSystem();
> mResources.startPreloading(); // 리소스는 크게 시스템 리소스와 애플리케이션으로 나뉘는데 시스템 리소스에 접근하려면 getSystem()에서 반환하는 객체를 이용하면 됨

> 중복된 호출로 인해 이미 로딩된 리소스가 다시 로딩되는 것을 막기위해서 멤버 변수에 리소스의 로딩 여부를 기록해두고 이미 로딩되어있다면 IllegalStateException 예외가 발생하고 메소드가 종료됨



5.3.3 SystemServer 실행

<그림>

+ ZygoteInit.java - startSystemServer() 
시스템 서버를 실행하는 메서드로 시스템 서버를 실행하기 위해 전달하는 인자가 하드코딩 되어있다. 
> com.android.server.SystemServer // 시스템 서버 클래스

> pid = Zygote.forkSystemServer(prasedArgs.uid, parsedArgs.gid, parsedArgs.gids, debugFlags, null); // forkSystemServer() 메서드를 통해 새로운 프로세스를 생성하고 시스템 서버를 실행

> handleSystemServerProcess(parsedArgs); // 생성된 시스템 서버 프로세스에서 “com.android.server.SystemServer” 클래스의 main() 메서드를 실행함

+ SystemServer.java - main()

> System.loadLibrary(“android_servers”); init1(args); // “android_servers”라는 라이브러리가 로딩되면서 JNI 네이티브 메서드에 등록되어있는 init1()함수가 호출, 이 함수에서 system_init() 함수가 호출.

+ system_init.cpp - system_init()

> SurfaceFlinger::instantiate(); // 네이티브 서버인 SurfaceFlinger, AudioFlinger, MediaPlayerService, CameraService를 실행

> runtime->callStatic(“com/android/server/SystemServer”, “init2”); // 서버가 등록되고 나면 init2()정적 메서드를 호출

+ SystemServer.java - init2()

> thr.setName(“android.server.ServerThread”); thr.start(); // init2()에서 안드로이드 프레임워크의 주요 서비스가 시작됨

> ServerThread가 생성되어 시작되면 ServerThread에서 재정의한 run() 메서드가 호출되는데 이 run()에 주요 서비스를 등록 및 실행하는 과정이 포함되어 있음 – 추후에 다룸

5.3.4 새로운 안드로이드 애플리케이션의 실행



+ runSelectLoopMode()
```
private static void runSelectLoopMode() throws MethodAndArgsCaller {
...
   fds.add(sServerSocket.getFileDescriptor()); 
// ZygoteInit::main() 앞부분에서 ‘/dev/socket/zygote’와 바인딩한 소켓 디스크립터를 배열에 추가
   while (true) {
   ...
      index = selectReadable(fdArray); 
// JNI의 네이티브 메서드로 등록돼있는 함수로 인자로 전달되는 디스크립터 배열을 감시하다가 디스크립터 목록에 이벤트가 있으면 해당 인덱스를 배열에 반환
   ...
      if (index < 0 ) {
         throw new RuntimeException(“Error in select()”);
      } else if (index == 0) { // 0번째 인덱스의 소켓 디스크립터 입출력 이벤트를 처리
         ZygoteConnection newPeer = acceptCommandPeer();
         peers.add(newPeer);
         fds.add(newPeer.getFileDescriptor());
      } else {
         boolean done;
         done = peers.get(index).runOnce(); // 새롭게 생성된 소켓 디스크립터 처리. 여기서 새로운 안드로이드 어플리케이션이 생성됨
         if (done) {
            peers.remove(index);
            fds.remove(index);
         }
      }
   }
}
```
> 0번째 인덱스는 새로운 연결 요청을 처리하기 위해 ZygoteConnection 클래스의 객체를 생성하고 해당 클래스의 생성자에서는 입출력 스트림을 생성하고 상대방의 접근 권한을 감시하기 위한 Credentials을 생성

+ ZygoteConnection.java – runOnce()

<그림>

> 메시지를 읽어들이고 요청 메시지로부터 생성한 문자열 배열을 분석하여 프로세스 실행을 위한 각종 옵션을 실행하는 메서드

> pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlinits); // 앞서 분석되고 준비된 각종 옵션을 인자로해서 Zygote 클래스의 forkAndSpecialize()를 호출하면 fork()가 호출되어 새로운 프로세스가 생성

```
if (pid == 0) {
   handleChildProc(parsedArgs, descriptor, newStderr); // 생성된 프로세스에 필요한 클래스를 로딩하고 클래스의 main()을 호출하면 프로세스가 시작
} else {
   return handleParentProc(pid, descriptors, parsedArgs); // 생성의 성공 및 실패 여부를 외부 프로세스로 반환, 성공한 경우 생성 프로세스의 pid 반환. 요청 종료 이후 연결을 종료하고 소켓을 닫는 작업수행
}

if (done) { // 처리가 완료된 소켓은 배열에서 제거
   peers.remove(index);
   fds.remove(index);
}
```
