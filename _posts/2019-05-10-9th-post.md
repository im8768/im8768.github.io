6. 안드로이드 서비스 개요

6.1 예제 프로그램 : 안드로이드 서비스 동작 이해

- ApiDemos 샘플 프로그램

6.2 안드로이드 서비스 분류

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/57489244-655fb780-72f0-11e9-8ea2-1cc54c9baa74.jpg">
</div>

그림과 같이 프레임워크에서 기본적으로 제공하는 시스템 서비스와 개발자가 Service 클래스를 상속해서 구현한 애플리케이션 서비스로 구분할 수 있다.

6.3 안드로이드 애플리케이션 서비스

애플리케이션 서비스는 안드로이드 SDK 의 Service 클래스를 확장한 클래스의 인스턴스로 UI 없이 주기적으로 특정한 일을 수행하는 백그라운드 프로세스를 가르킨다.

개발자는 서비스를 두 가지 방법으로 이용할 수 있다.

> 서비스 시작, 종료 : 특정 기능을 수행하는 서비스를 백그라운드로 실행/종료

> 바인딩을 통한 서비스 원격제어 : 서비스 클라이언트가 서비스에 바인딩을 하게되면 바인딩이 유지되는 동안 서비스가 제공하는 인터페이스를 통해 기능 제어

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/57489245-655fb780-72f0-11e9-8c84-1e5e34be6485.jpg">
</div>

서비스는 안드로이드 애플리케이션 컴포넌트이므로 그림과 같은 생명주기를 가진다

6.3.1 애플리케이션 서비스의 분류

애플리케이션 서비스는 로컬 서비스와 리모트 서비스로 구분되며 이를 구분하는 기준은 서비스와 이를 생성한 서비스 클라이언트가 동일한 프로세스에서 동작하고 있는지의 여부다.

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/57489247-655fb780-72f0-11e9-9bea-e9e281b9903f.jpg">
</div>

> 로컬 서비스의 경우 동일 프로세스에서 동작하기 때문에 클라이언트 프로그램이 바인딩할 로컬 서비스의 레퍼런스만 얻으면 된다.

> 리모트 서비스의 경우 별개의 프로세스에서 동작하므로 IPC 메커니즘을 이용해야한다. 바인더 IPC가 사용된다.


<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/57489248-65f84e00-72f0-11e9-97bb-7f7979bff350.jpg">
</div>

```
private OnClickListener mBindListener = new OnClickListener() {
   public void onClick(View v) {
      doBindService();
   }
};

void doBindService() {
   bindService(new Intent(Binding.this, LocalService.class), mConnection, Context.BIND_AUTO_CREATE);
   mIsBound = true;
}
```
1) Bind Service 버튼 이벤트 핸들러의 주요코드

버튼을 클릭하면 doBindService가 호출되며 이 메서드에서 bindservice() API를 사용해서 LocalService 바인딩을 시도한다.

```
public IBinder onBind(Intent intent) {
   return mBinder;
}

private final IBinder mBinder = new LocalBinder();

public class LocalBinder extends Binder {
   LocalService getService() {
      return LocalService.this;
   }
}
```


2) 바인딩 처리를 위해 서비스의 onBind() 콜백 메서드를 호출, onBind() 메서드는 액티비티가 LocalService 자신과 연결할 수 있게 LocalBinder 객체를 반환한다.

```
private ServiceConnection mConnection = new ServiceConnection() {

   public void onServiceConnected(ComponentName className, IBinder service) {
      mBoundService = ((LocalService.LocalBinder)service).getService();
   }
   public void onServiceDisconnected(ComponentName className) {
      mBoundService = null;
   }
};
```
3) 서비스가 바인딩을 처리할 객체를 생성했다면 프레임워크는 서비스 클라이언트 측 메서드를 호출한다. 이때 메서드의 인자에는 onBinder()에서 생성된 LocalBinder 객체의 레퍼런스가 전달된다. Binding 액티비티는 LocalBinder 객체의 getService() 메서드를 호출해서 바인딩하려고 했던 LocalService 객체의 레퍼런스 값을 구한다.

4) 구해진 레퍼런스값을 액티비티의 mBoundService 멤버 필드에 저장하면 서비스 바인딩이 마무리 된다.

* 리모트 서비스

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/57489249-65f84e00-72f0-11e9-83e4-1cd45a702a3f.jpg">
</div>

> Local Service Binding 예제와는 달리 ISecondary.aidl 파일과 이 파일에 의해 자동생성된 ISecondary.java 파일이 추가됨

```
interface ISecondary {
   int getPid();
}
```
안드로이드 SDK는 aidl 파일을 참조해서 자동으로 코드를 생성해준다. 이렇게 생성된 코드가 ISecondary.java 파일인데 이 코드는 서비스 클라이언트와 리모트 서비스 간의 ISecondary 인터페이스에 기반한 바인더 PIC 연결을 설정하는 역할을 한다.

즉, 이 코드를 통해 ISecondary 인터페이스에 포함된 getPid() 메서드를 해당 클래스에 포함된 메서드를 호출하듯 호출할 수 있다. 하지만 getPid()의 실제코드는 RemoteService 개발자가 직접 구현해야한다.

* 리모트 서비스의 바인딩 과정

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/57489250-65f84e00-72f0-11e9-9bcd-1eeb6916b71a.jpg">
</div>


1) Binding 액티비티 : RemoteService와의 연결 요청

2) RemoteService 서비스 : 실제 서비스 메서드 기능 구현 및 서비스와 통신하기 위한 바인더 객체 제공

3) Binding 액티비티 : 서비스와 바인더 IPC를 수행하기 위한 프록시 객체 생성

4) Binding 액티비티 : 서비스 프록시 객체를 이용해서 RemoteService 서비스의 getPid() 서비스 프록시 메서드를 호출

5) 바인더 IPC : 서비스 프록시 객체에서 서비스 바인더 객체로 바인더 IPC 데이터 전달

6) RemoteService 서비스 : RemoteService 서비스의 getPid() 스텁 메서드 호출

6.4 안드로이드 시스템 서비스

6.4.1 시스템 서비스의 종류

* 네이티브 시스템 서비스 ( Audio Flinger, Surface Flinger 등)
> C++ 로 작성되어 있다.

Audio Flinger
> 안드로이드 애플리케이션의 오디오 데이터를 믹싱해서 오디오 출력장치로 내보내는 역할

Surface Flinger
> 다양한 애플리케이션에서 사용중인 Surface를 조합해 프레임 버퍼 장치로 렌더링

* 자바 시스템 서비스
> 안드로이드 부팅 시 SystemServer 라는 시스템 프로세스에 의해 일괄적으로 실행

* 코어 플랫폼 서비스
> 일반적으로 애플리케이션과 직접 상호작용은 하지 않지만 프레임워크가 동작하는데 필수적인 서비스

```
Activity Manager Service : 모든 액티비티에 대한 라이프 사이클 및 스택 관리
Window Manager Service : 기기 화면에 그릴 내용을 Surface Flinger로 전달
Package Manager Service : apk 파일 정보 로딩, 시스템에 설치/로딩 된 패키지 정보전달
```

* 하드웨어 서비스
> 저수준 하드웨어 제어를 위한 API를 제공하는 서비스
* 자바 시스템 서비스 이용
> 이러한 자바 시스템 서비스를 이용하려면 각 서비스와 통신 가능한 Local Manager 객체를 이용해야한다. (예시 : Location Service를 이용하려면 getSystemService() 함수를 이용해서 Location Manager 인스턴스를 생성)

6.5 시스템 서비스의 실행

애플리케이션 실행시 일반적으로 startService() API함수를 이용하지만 시스템 서비스는 getSystemService()를 이용해서 서비스 직접 실행없이 이용 가능하다.

시스템 서비스는 `미디어 서버` 와 `시스템 서버` 라는 두 시스템 프로세스에 의해 실행된다.
> 미디어 서버 : Surface Flinger를 제외한 네이티브 서비스 실행

> 시스템 서버 : Zygote에 의해 맨 처음 생성되는 자바 기반의 프로세스로 Surface Flinger를 포함한 모든 자바 시스템 서비스 실행

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/57489252-65f84e00-72f0-11e9-8463-4a73a8316f17.jpg">
</div>


6.5.1 미디어 서버의 실행 코드 분석

init 프로세스로부터 실행

```
service media /system/bin/mediaserver
   user media
   group system audio camera graphics inet net_bt net_bt_admin
```
> init.rc에서 미디어 서버가 실행되는 부분



```
int main(int argc, char** argv){
   ...
   AudioFlinger::instantiate();
   ...
}
//Audio Flinger 초기화 코드
//frameworks/base/libs/audioFlinger/AudioFlinger.cpp
void AudioFlinger::Instantiate() {
   defaultServiceManager()->addService(String16(“media.audioFlinger”), new AudioFlinger());
```
서비스의 인스턴스를 생성한 다음 생성된 서비스를 컨텍스트 매니저에 등록하는 것이 전부

6.5.2 시스템 서버의 실행 코드 분석

* Zygote 프로세스로부터 생성
* android_servers 라이브러리 로드

1. main() 메서드의 기능은 android_servers 라이브러리를 로드하고 init1() 메서드를 호출 하는 것
2. Surface Flinger는 C++ 기반 프로그램이므로 자바 프로세스인 시스템 서버 프로세스가 직접 호출할 수 없다. 따라서 JNI를 이용해 system_init() 네이티브 함수를 호출해서 실행
3. Surface Flinger 서비스를 실행하고나면 SystemServer 클래스의 init2() 메서드를 호출.
callStatic() 함수는 C++ 코드에서 JNI를 이용해 자바 클래스의 정적 메서드를 호출할 수 있게 만든 JNI 래핑 함수

* 자바 시스템 서비스 초기화 및 등록

4. init2() 메서드에서는 ServerThread를 생성하고 실행. ServerThread는 안드로이드의 모든 자바 시스템 서비스를 실행하는 자바 스레드

5. C++ 기반의 네이티브 시스템 서비스와는 다르게 자바 시스템 서비스는 ServiceManager 클래스의 addService() 정적 메서드를 이용해서 컨텍스트 매니저에 자신을 등록

* foo() 서비스 프록시 함수

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/57489243-655fb780-72f0-11e9-801c-2cb5f81ae589.jpg">
</div>

1. 서비스 사용자는 foo() 프록시 함수를 호출해서 바인더 RPC 데이터를 전달
2. 바인더 RPC 데이터는 마샬링을 거쳐 서비스 프레임워크를 통해 바인더 IPC 데이터로 생성
3. 바인더 드라이버를 통해 서비스 서버 측에 전송

4. 서비스 서버측에서 수신된 IPC 데이터는 서비스 프레임워크를 거치며 언마샬링
5. 서비스 스텁의 onTransact() 함수에 전송
6. 서비스 스텁은 해당 바인더 IPC 데이터 안에 포함된 RPC 코드를 통해 Foo 서비스의 foo() 서비스 스텁 함수에 대한 바인더 RPC임을 판단
