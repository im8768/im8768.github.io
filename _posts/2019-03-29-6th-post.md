4.3 JNI 함수 이용하기

* 자바 객체 생성
* 클래스의 정적 멤버 필드에 접근하기
* 클래스의 정적 메서드 호출하기
* 자바 객체의 멤버 필드에 접근하기
* 자바 객체의 메서드 접근하기

4.3.1 JNI 함수를 활용하는 예제 프로그램의 구조

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/55975881-e0b85400-5cc5-11e9-9811-6241c1579e8e.jpg">
</div>


4.3.2 자바측 코드 살펴보기

- JniFuncMain 클래스

```
public class JniFuncMain{

   private static int staticIntField = 300;

//jnitest.dll 라이브러리 미리 로드
   static { System.loadLibrary(“Jnifunc”); }

//네이티브 메서드 선언
   public static native JniTest createJniObject();

   public static void main(String[] args)
   {
      // 네이티브 코드로부터 JniTest 객체 생성
      System.out.println(“[Java] createJniObject() 네이티브 메서드 호출”);
      JniTest jniObj = createJniObject();

      // JniTest 객체의 메서드 호출
      JniObj.callTest();

   }
}
```

- JniTest 클래스
```
class JniTest
{
   private int intfield;

   //생성자
   public JniTest(int num)
   {
      intField = num;
      System.out.println(“[Java] JniTest 객체의 호출 : intField = ” + intfield);
   }
   
   // JNI 네이티브 함수로부터 호출될 메서드
   public int callByNative(int num)
   {
      System.out.println(“[Java] JniTest 객체의 callByNative(” + num + “) 호출”);
      return num;
   }

   public void callTest()
   {
       System.out.println(“[Java] JniTest 객체의 callTest() 메서드 호출 : intField = ” + intField);
   }
```

4.3.3 JNI 네이티브 함수 코드 살펴보기

- JniFuncMain.h(명령어 : javah JniFuncMain) 

`JNIEXPORT jobject JNICALL Java_JniFuncMain_createJniObject(JNIEnv *, jclass)`
createJniObject() 메서드에 대해 위와 같은 JNI 네이티브 함수의 원형이 생성됨

여기서 두 번째 매개변수가 jobject가 아니라 jclass 타입인 이유?

`public static native JniTest createJniObject();`
static 메서드로 선언되어 있다. 자바에서 정적 메서드는 객체를 생성하지 않고도 클래스를 호출할 수 있기에 객체가 아닌 클래스로 호출되기 때문

createJniObject 네이티브 메서드는 JniFuncMain 클래스를 통해 호출되기 때문에 두 번째 매개변수로 JniFuncMain 클래스 레퍼런스가 넘어옴

- jnifunc.cpp 파일

+ JNI를 통한 멤버 필드 값 얻어오기

```
//1. 접근하려는 멤버 변수가 포함된 JniFuncMain 클래스의 jclass 값 찾기

//2. “staticIntField”에 대한 필드 ID값 구함
fid = env->GetStaticFieldID(class, “staticIntField”, “I”);

//3. jclass 와 fieldid가 가리키는 멤버 변수값 읽어옴
staticIntField = env->GetStaticIntField(clazz,fid);
```


+객체 생성하기
```
//1. 객체를 생성할 클래스 찾기
targetClass = env->FindClass(“JniTest”);

//2. 생성자 찾기
mid = env->GetMethodID(targetClass, “<init>”, “(I)V”);

//3. JniTest 객체 생성(생성된 객체 레퍼런스 반환)
newObject = env->NewObject(targetClass, mid, 100);
```


+자바 메서드 호출하기
```
//1. 호출할 메서드가 포함된 자바 클래스의 jclass 값을 구함
targetClass = env->GetObjectClass(newObject);

//2. 호출할 메서드와 메서드 ID 값을 구함
mid = env->GetMethodID(targetClass, “callByNative”,“(I)I”);

//3. 호출하려는 메소드
result = env->CallIntMethod(newObject, mid, 200);
```

+JNI를 통한 멤버 필드 값 설정하기
```
//1. IntField 멤버 변수를 포함한 JniTest 클래스의 jclass 값 구함
//이미 target class에 저장되어 있음

//2. JniTest 객체의 “IntField”에 대한 필드 ID값을 구함
fid = env->GetFieldID(targetClass, “intField”, “I”);

//3. IntField의 값을 result 변수의 값으로 설정
env->SetIntField(newObject, fid, result);
```

4.4 C프로그램에서 자바 클래스 실행하기

4.4.1 호출 API 사용 예제

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/55975883-e0b85400-5cc5-11e9-99eb-b0070265c760.jpg">
</div>

- 자바코드(InvocationApiTest.java) 살펴보기

```
public class InvocationApiTest
{
   public static void main(String[] args)
   {
      System.out.println(args[0]);
   }
}
//문자형 객체 배열을 인자로 받아 그 중 첫 번째 문자열을 화면에 출력하는 기능
```

- C 코드(InvocationApi.c) 살펴보기

1. #include <jni.h> : 네이티브 코드에서 JNI를 이용하려면 반드시 포함해야함.
2. 자바 가상 머신이 로딩될 때 참조할 옵션 값 생성, 여기서 설정한 옵션은 자바 가상 머신의 환경을 설정하거나 동작을 제어하는데 쓰임

+ 자바 가상머신에 넘길 옵션값을 생성할 때 사용하는 구조체 예시(jni.h에 정의)
```
typedef struct JavaVMInitArgs {
   jint version; // 매개변수의 형식을 지정(JNI_VERSION_1_2 값 지정)
   jint nOptions; // 구조체 배열의 원소 개수 지정
// 내부적으로 JavaVMOption 구조체를 포함
   JavaVMOption *options; // 구조체 배열의 주소 지정
   jboolean ignoreUnrecognized; 
// 잘못 정의된 옵션 값을 만났을 때 계속 진행할지 오류를 반환하고 종료할지 지정
// JNI_FALSE 값으로 설정하면 오류 반환하고 바로 종료
} JavaVMInitArgs;
-> 각 옵션을 묶어서 자바 가상머신으로 전달

typedef struct JavaVMOption {
   char *optionString; // 옵션값 생성
   void *extraInfo;
} JavaVMOption;
-> 각 옵션의 값을 나타냄
```

3. res = JNI_CreateJavaVM(&vm, (void**)&env, &vm_args); : 자바 가상머신 생성
JNI_CreateJavaVM() 함수의 첫 인자 타입인 JavaVM은 자바 가상 머신 인터페이스를 나타냄
두 번째 인자 env에는 JNI 인터페이스 포인터의 주소 저장

4. 
```
//실행할 클래스 검색 후 로드
cls = (*env)->FindClass(env, InvocationApiTest“);
//main() 메서드의 메서드 ID 획득
mid = (*env)->GetStaticMethodID(env, cls, “main”, “([Ljava/lang/String;)V”);
```
FindClass()를 이용해 InvocatonApiTest 클래스 로드
클래스 안의 main() 메서드를 호출하기 위해 메서드 ID 획득

5. CallStaticVoidMethod()를 통해 main() 호출하기전 메서드에 넘길 인자 생성
`public static void main(String[] args)`

NewStringUTF() JNI 함수를 이용해 UTF-8 형식의 C 문자열을 자바의 String 객체로 변환
NewObjectArray()를 이용해 String 객체 배열을 만들고 초기화


4.5 JNI 네이티브 함수 직접 등록하기

1. System.loadLibrary() 메서드를 이용해서 네이티브 메서드의 실제 구현이 포함된 C/C++ 라이브러리를 메모리 상에 로드
2. 자바 가상 머신은 위에서 로드된 라이브러리의 함수 심볼을 검색해서 자바에서 선언된 네이티브 메서드의 시그니처와 일치하는 JNI 네이티브 함수 심볼을 찾은 다음 네이티브 메서드와 실제 구현인 JNI 네이티브 함수를 매핑

> 네이티브 메서드에 포함된 자바 클래스가 많은 경우 자바 가상머신이 라이브러리를 로딩하고 일일이 심볼을 검색해서 매핑하는 작업은 성능 저하의 원인이 됨

> 개발자가 JNI 네이티브 함수를 매핑할 수 있게 해주는 RegisterNatives() JNI 함수 제공, 해당 함수를 통해 별도 매핑 과정 생략이 가능(로딩 속도 향상)

> 개발자가 직접 연결하므로 JNI 네이밍 룰에 맞출 필요가 없음


4.5.1 네이티브 라이브러리 로드 시에 JNI 네이티브 함수 등록하기

- System.loadLibrary() 메서드의 동작방식
1. 호출하면 주어진 이름을 가진 공유 라이브러리를 로드
2. 로드한 라이브러리 내의 함수 심볼 검색 -> JNI_OnLoad() 구현 확인 후 구현시 함수호출
3. 구현되어있지 않다면 자동으로 네이티브 메서드와 라이브러리 내의 JNI 네이티브 함수의 심볼 비교해서 매핑

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/55976237-a8fddc00-5cc6-11e9-8414-e05162e1ce52.jpg">
</div>
