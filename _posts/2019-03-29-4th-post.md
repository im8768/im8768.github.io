3.4 디바이스 노드 파일 생성

애플리케이션은 디바이스 드라이버를 통해 하드웨어에 접근하는데 디바이스 드라이버에 접근하기 위해 디바이스 노드 파일을 사용함. 리눅스와는 달리 보안문제로 mknod 와 같은 유틸리티 디바이스 생성 유틸리티를 제공하지 않으므로 안드로이드의 생성 방법을 따라야함.

3.4.1 정적 디바이스 노드 생성

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/55179859-bfd30780-51cb-11e9-9915-28fcaf77fab6.jpg">
</div>


안드로이드는 /dev 디렉터리가 존재하지 않으므로 init 프로세스를 활용하여 디바이스 노드파일을 생성해줘야함

init 프로세스는 두가지 방법으로 디바이스 노드 파일을 생성함
```
1. 미리 정의된 디바이스 정보를 바탕으로 init 프로세스 실행시 일괄적으로 생성(Cold Plug)
2. USB 포트에 장치가 삽입될 때 이에 대한 이벤트 처리로 동적으로 생성(Hot Plug)
```

* Cold Plug

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/55179860-c06b9e00-51cb-11e9-86e5-52c41e4ba92d.jpg">
</div>

udev 데몬을 통한 디바이스 노드 파일 생성
백그라운드로 실행중인 udev 데몬은 드라이버의 uevent 메시지를 분석하여 /sys 디렉토리에 등록된 디바이스 정보를 보고 “/dev” 디렉터리의 적절한 위치에 디바이스 노드 파일을 생성한다. udev는 커널 동작 이후 실행되는 프로세스이므로 커널 부팅중의 uevent를 처리하지 못하는 문제가 있다.
```
uevent : 커널이 디바이스 추가 및 제거 시 해당 디바이스의 정보를 사용자 공간으로 전달하기 위해 사용하는 신호 체계
```


이 때 init 프로세스가 udev를 대신하여 디바이스 노드를 생성하는데 바인더 드라이버가 활용된다. 바인더 드라이버는 사용자 공간의 init 프로세스를 통해 디바이스 노드 파일을 생성해야 하지만 init 프로세스가 부팅중이기 때문에 /sys 디렉토리에 드라이버 정보를 등록한다.

커널 부팅이 완료되면 init 프로세스는 바인더 드라이브처럼 디바이스 노드 파일을 생성하지 못한 드라이버에 대해 콜드 플러그 처리를 한다.

* 콜드 플러그 처리 절차

```
int device_init(void)
{
   fd = open_uevent_socket();
   t0 = get_usecs();
   coldboot(fd, “/sys/class”);
   coldboot(fd, “/sys/block”);
   coldboot(fd, “/sys/devices”);
   t1 = get_usecs();
   log_event_print(“coldboot %ld uS\n”, ((long) (t1 – t0)));
}
```

1. device_init() 함수는 uevent를 수신하기 위한 socket을 생성함

2. coldboot() 함수는 do_coldboot() 함수를 호출하여 커널 부팅 시 sys 디렉토리에 정보를 등록한 드라이버에 대해 콜드플러그 처리를 함

3. do_coldboot() 함수는 인자로 디렉터리 경로를 받아 uevent 파일을 찾은 후 해당 파일에 “add” 메시지를 넣어 강제로 uevent를 발생시킴, 이후 handle_device_fd() 함수에서 uevent를 수신하고 uevent에 실린 메시지를 파악함.

4. handle_device_fd() 함수는 uevent 수신 이후 parse_event() 함수를 호출하고 uevent 메시지를 uevent 구조체에 할당함

5. uevent 구조체가 완성되면 handle_device_event() 함수를 호출하여 실제 노드 파일을 생성함

```
3.4.2 동적 디바이스 감지

int main(int argc, char **argv)
{
   for(;;) {
      nr = poll(ufds, fd_count, timeout);
      .
      .
      if (ufds[0].revents == POLLIN)
         handle_device_fd(device_fd);
   }
   ...
} 
```
init.c – main() - 디바이스 이벤트 처리

init 프로세스는 이벤트 처리 루프에서 poll() 함수를 통해 드라이버로부터 발생하는 uevent를 감지하고 handle_device_fd() 함수를 호출하고 해당 함수를 통해 디바이스 노드 파일을 생성함

3.5 프로세스 종료와 재시작

init 프로세스는 init.rc 파일로부터 파싱한 서비스 리스트를 통해 아래와 같은 주요 프로세스들을 순차적으로 실행함
```
sh : 터미널, 시리얼 혹은 adbd 접속 시 콘솔 입출력을 제공하는 셀 프로그램
adbd(Android Debug Bridge) : QEMU 에뮬레이터나 실제 기기의 상태를 관리하는 데 쓰는 툴로 클라이언트 서버의 일종
servicemanager : 안드로이드 시스템 서비스의 목록을 관리
void : Volume 데몬을 의미하며 USB 스토리지나 SD 카드 장치 마운트 및 관리
playmp3 : 안드로이드 부팅 시 부팅 사운드 출력
```
시스템 동작에 영향을 미치는 프로세스들이 다수이므로 해당 프로세스들은 대부분 종료되더라도 init 프로세스에 의해 재시작됨

3.5.1 프로세스 재시작 코드 분석
```
static void sigchld_handler(int s)
{
   write(signal_fd, %s, 1);
}
```
sigchld_handler() 함수는 SIGCHLD 시그널에 의해 호출되는데 이때 SIGCHLD 시그널 번호를 인자로 받고 해당 번호를 소켓 디스크립터에 기록함
```
for (;;) {
   nr = poll(ufds, fd_count, timeout);
   if ( nr <= 0 )
      continue;
   if (ufds[2].revents = POLLIN) {
      read(signal_recv_fd, tmp, sizeof(tmp));
      while (!wait_for_one_process(0));
      continue;
   }
   ...
}
```

1. poll() 함수는 SIGCHLD 시그널 발생 시 이벤트 감시상태에서 빠져나와 이후 코드 실행
2. signal_revc_fd는 ufds[2]에 등록돼 있고 데이터 입력에 의해 이벤트가 발생했으므로 wait_for_one_process() 함수를 수행함
해당 함수는 SIGCHLD가 발생시킨 프로세스가 가진 서비스 리스트에서 옵션을 체크하고 옵션이 oneshot(SVC_ONE_SHOT)이 아닌 경우 재시작 옵션을 추가함


3.6 프로퍼티 서비스


init 프로세스의 이벤트 처리 루프에서 처리하는 또 다른 이벤트는 프로퍼티의 변경 요청
안드로이드 플랫폼은 시스템이 동작하는데 필요한 각종 설정 값을 공유하는 프로퍼티라는 저장 공간을 사용하고 접근하기 위한 API를 제공함


3.6.1 프로퍼티 초기화

<div>
<img width="100%" src="https://user-images.githubusercontent.com/34255526/55179863-c06b9e00-51cb-11e9-9574-eeab683d801a.jpg">
</div>


1. init 프로세스의 main() 함수 초기에 프로퍼티 영역을 초기화하기 위해 property_init() 이 호출됨
2. property_init() 함수는 프로퍼티 값을 저장하기 위한 공유메모리를 생성하는데 Android Shared Memory를 사용함

```
void property_init(void)
{
   init_property_area();
   load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT);
}
int main(int argc, char **argv)
{
   ...
   property_init();
   ...
}
```
property_init() 함수는 init_property_area() 함수를 이용해 공유 메모리로 프로퍼티 영역을 생성하는데 생성된 공간의 앞부분, 헤더에는 프로퍼티 테이블을 관리하는 데 필요한 값이 저장되고 나머지 공간에는 247개의 프로퍼티 값을 저장하는 공간이 할당됨.

이 값을 저장하거나 조회할 때는 `property_get(), property_set()` 함수를 이용함

3.6.2 프로퍼티 변경 요청 처리

프로퍼티 값의 변경 요청 메시지가 수신되면 `handle_property_set_fd()` 함수가 호출됨
